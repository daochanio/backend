// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: queries.sql

package bindings

import (
	"context"
	"database/sql"
	"time"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comments (address, thread_id, content)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateCommentParams struct {
	Address  string
	ThreadID int64
	Content  string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createComment, arg.Address, arg.ThreadID, arg.Content)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCommentDownVote = `-- name: CreateCommentDownVote :exec
INSERT INTO comment_votes (address, comment_id, vote)
VALUES ($1, $2, -1)
ON CONFLICT (address, comment_id) DO UPDATE SET vote = -1, updated_at = NOW()
`

type CreateCommentDownVoteParams struct {
	Address   string
	CommentID int64
}

func (q *Queries) CreateCommentDownVote(ctx context.Context, arg CreateCommentDownVoteParams) error {
	_, err := q.db.ExecContext(ctx, createCommentDownVote, arg.Address, arg.CommentID)
	return err
}

const createCommentUnVote = `-- name: CreateCommentUnVote :exec
INSERT INTO comment_votes (address, comment_id, vote)
VALUES ($1, $2, 0)
ON CONFLICT (address, comment_id) DO UPDATE SET vote = 0, updated_at = NOW()
`

type CreateCommentUnVoteParams struct {
	Address   string
	CommentID int64
}

func (q *Queries) CreateCommentUnVote(ctx context.Context, arg CreateCommentUnVoteParams) error {
	_, err := q.db.ExecContext(ctx, createCommentUnVote, arg.Address, arg.CommentID)
	return err
}

const createCommentUpVote = `-- name: CreateCommentUpVote :exec
INSERT INTO comment_votes (address, comment_id, vote)
VALUES ($1, $2, 1)
ON CONFLICT (address, comment_id) DO UPDATE SET vote = 1, updated_at = NOW()
`

type CreateCommentUpVoteParams struct {
	Address   string
	CommentID int64
}

func (q *Queries) CreateCommentUpVote(ctx context.Context, arg CreateCommentUpVoteParams) error {
	_, err := q.db.ExecContext(ctx, createCommentUpVote, arg.Address, arg.CommentID)
	return err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :exec
INSERT INTO users (address, ens_name)
VALUES ($1, $2)
ON CONFLICT (address) DO UPDATE SET ens_name = $2, updated_at = NOW()
`

type CreateOrUpdateUserParams struct {
	Address string
	EnsName sql.NullString
}

// create/update user every time the sign-in
func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, createOrUpdateUser, arg.Address, arg.EnsName)
	return err
}

const createParentClosures = `-- name: CreateParentClosures :exec
INSERT into comment_closures (thread_id, parent_id, child_id, depth)
SELECT p.thread_id, p.parent_id, c.child_id, p.depth + c.depth+1
FROM comment_closures p, comment_closures c
WHERE p.child_id = $1 AND c.parent_id = $2
AND p.thread_id = $3
AND c.thread_id = $3
`

type CreateParentClosuresParams struct {
	ChildID  int64
	ParentID int64
	ThreadID int64
}

// only do if not root comment (i.e parent_id != child_id)
func (q *Queries) CreateParentClosures(ctx context.Context, arg CreateParentClosuresParams) error {
	_, err := q.db.ExecContext(ctx, createParentClosures, arg.ChildID, arg.ParentID, arg.ThreadID)
	return err
}

const createSelfClosure = `-- name: CreateSelfClosure :exec
INSERT INTO comment_closures (thread_id, parent_id, child_id, depth)
VALUES ($1, $2, $2, 0)
`

type CreateSelfClosureParams struct {
	ThreadID int64
	ParentID int64
}

func (q *Queries) CreateSelfClosure(ctx context.Context, arg CreateSelfClosureParams) error {
	_, err := q.db.ExecContext(ctx, createSelfClosure, arg.ThreadID, arg.ParentID)
	return err
}

const createThread = `-- name: CreateThread :one
INSERT INTO threads (address, content)
VALUES ($1, $2)
RETURNING id
`

type CreateThreadParams struct {
	Address string
	Content string
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createThread, arg.Address, arg.Content)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createThreadDownVote = `-- name: CreateThreadDownVote :exec
INSERT INTO thread_votes (address, thread_id, vote)
VALUES ($1, $2, -1)
ON CONFLICT (address, thread_id) DO UPDATE SET vote = -1, updated_at = NOW()
`

type CreateThreadDownVoteParams struct {
	Address  string
	ThreadID int64
}

func (q *Queries) CreateThreadDownVote(ctx context.Context, arg CreateThreadDownVoteParams) error {
	_, err := q.db.ExecContext(ctx, createThreadDownVote, arg.Address, arg.ThreadID)
	return err
}

const createThreadUnVote = `-- name: CreateThreadUnVote :exec
INSERT INTO thread_votes (address, thread_id, vote)
VALUES ($1, $2, 0)
ON CONFLICT (address, thread_id) DO UPDATE SET vote = 0, updated_at = NOW()
`

type CreateThreadUnVoteParams struct {
	Address  string
	ThreadID int64
}

func (q *Queries) CreateThreadUnVote(ctx context.Context, arg CreateThreadUnVoteParams) error {
	_, err := q.db.ExecContext(ctx, createThreadUnVote, arg.Address, arg.ThreadID)
	return err
}

const createThreadUpVote = `-- name: CreateThreadUpVote :exec
INSERT INTO thread_votes (address, thread_id, vote)
VALUES ($1, $2, 1)
ON CONFLICT (address, thread_id) DO UPDATE SET vote = 1, updated_at = NOW()
`

type CreateThreadUpVoteParams struct {
	Address  string
	ThreadID int64
}

func (q *Queries) CreateThreadUpVote(ctx context.Context, arg CreateThreadUpVoteParams) error {
	_, err := q.db.ExecContext(ctx, createThreadUpVote, arg.Address, arg.ThreadID)
	return err
}

const deleteComment = `-- name: DeleteComment :one
UPDATE comments
SET is_deleted = TRUE, deleted_at = NOW()
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteComment(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteComment, id)
	err := row.Scan(&id)
	return id, err
}

const deleteThread = `-- name: DeleteThread :one
UPDATE threads
SET is_deleted = TRUE, deleted_at = NOW()
WHERE id = $1
RETURNING id
`

func (q *Queries) DeleteThread(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteThread, id)
	err := row.Scan(&id)
	return id, err
}

const getRootAndFirstDepthComments = `-- name: GetRootAndFirstDepthComments :many
SELECT comments.id, comments.thread_id, comments.address, comments.content, comments.is_deleted, comments.created_at, comments.deleted_at, SUM(COALESCE(comment_votes.vote, 0)) as votes
FROM comments
LEFT JOIN comment_votes on comments.id = comment_votes.comment_id
WHERE comments.id NOT IN (
	SELECT child_id
	FROM comment_closures
	where depth > 1
)
AND comments.thread_id = $1
GROUP BY comments.id
ORDER BY comments.created_at ASC
`

type GetRootAndFirstDepthCommentsRow struct {
	ID        int64
	ThreadID  int64
	Address   string
	Content   string
	IsDeleted bool
	CreatedAt time.Time
	DeletedAt sql.NullTime
	Votes     int64
}

// select root and first depth comments
// left join incase there are comments with no votes
// coalesce as well for no vote comments
// TODO: This kind of works but we need to paginate this query
// But I think we need to paginate the root comments without the children, as including the children will throw of the pagination count
func (q *Queries) GetRootAndFirstDepthComments(ctx context.Context, threadID int64) ([]GetRootAndFirstDepthCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRootAndFirstDepthComments, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRootAndFirstDepthCommentsRow
	for rows.Next() {
		var i GetRootAndFirstDepthCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.Address,
			&i.Content,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Votes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThread = `-- name: GetThread :one
SELECT
	threads.id, threads.address, threads.content, threads.is_deleted, threads.created_at, threads.deleted_at,
	SUM(COALESCE(thread_votes.vote, 0)) as votes
FROM threads
LEFT JOIN thread_votes ON thread_votes.thread_id = threads.id
WHERE threads.id = $1
AND threads.is_deleted = FALSE
GROUP BY threads.id
`

type GetThreadRow struct {
	ID        int64
	Address   string
	Content   string
	IsDeleted bool
	CreatedAt time.Time
	DeletedAt sql.NullTime
	Votes     int64
}

func (q *Queries) GetThread(ctx context.Context, id int64) (GetThreadRow, error) {
	row := q.db.QueryRowContext(ctx, getThread, id)
	var i GetThreadRow
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Content,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Votes,
	)
	return i, err
}

const getThreads = `-- name: GetThreads :many
SELECT
  threads.id, threads.address, threads.content, threads.is_deleted, threads.created_at, threads.deleted_at,
  SUM(COALESCE(thread_votes.vote, 0)) as votes
FROM threads
LEFT JOIN thread_votes ON thread_votes.thread_id = threads.id
WHERE threads.is_deleted = FALSE
GROUP BY threads.id
ORDER BY threads.created_at ASC
OFFSET $1
LIMIT $2
`

type GetThreadsParams struct {
	Offset int32
	Limit  int32
}

type GetThreadsRow struct {
	ID        int64
	Address   string
	Content   string
	IsDeleted bool
	CreatedAt time.Time
	DeletedAt sql.NullTime
	Votes     int64
}

// TODO: We can order by random in the future
func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]GetThreadsRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreads, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsRow
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Content,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Votes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
