// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: api.sql

package bindings

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const aggregateCommentVotes = `-- name: AggregateCommentVotes :exec
UPDATE comments
SET votes = (
	SELECT COALESCE(SUM(vote), 0)
	FROM comment_votes
	WHERE comment_votes.comment_id = $1
)
WHERE comments.id = $1
`

func (q *Queries) AggregateCommentVotes(ctx context.Context, commentID int64) error {
	_, err := q.db.Exec(ctx, aggregateCommentVotes, commentID)
	return err
}

const aggregateThreadVotes = `-- name: AggregateThreadVotes :exec
UPDATE threads
SET votes = (
	SELECT COALESCE(SUM(vote), 0)
	FROM thread_votes
	WHERE thread_votes.thread_id = $1
)
WHERE threads.id = $1
`

func (q *Queries) AggregateThreadVotes(ctx context.Context, threadID int64) error {
	_, err := q.db.Exec(ctx, aggregateThreadVotes, threadID)
	return err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (address, thread_id, replied_to_comment_id, content, image_file_name, image_original_url, image_original_content_type, image_formatted_url, image_formatted_content_type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id
`

type CreateCommentParams struct {
	Address                   string
	ThreadID                  int64
	RepliedToCommentID        pgtype.Int8
	Content                   string
	ImageFileName             string
	ImageOriginalUrl          string
	ImageOriginalContentType  string
	ImageFormattedUrl         string
	ImageFormattedContentType string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.Address,
		arg.ThreadID,
		arg.RepliedToCommentID,
		arg.Content,
		arg.ImageFileName,
		arg.ImageOriginalUrl,
		arg.ImageOriginalContentType,
		arg.ImageFormattedUrl,
		arg.ImageFormattedContentType,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCommentDownVote = `-- name: CreateCommentDownVote :exec
INSERT INTO comment_votes (address, comment_id, vote)
VALUES ($1, $2, -1)
ON CONFLICT (address, comment_id) DO UPDATE SET vote = -1, updated_at = NOW()
WHERE comment_votes.updated_at < TO_TIMESTAMP($3)
`

type CreateCommentDownVoteParams struct {
	Address     string
	CommentID   int64
	ToTimestamp float64
}

func (q *Queries) CreateCommentDownVote(ctx context.Context, arg CreateCommentDownVoteParams) error {
	_, err := q.db.Exec(ctx, createCommentDownVote, arg.Address, arg.CommentID, arg.ToTimestamp)
	return err
}

const createCommentUnVote = `-- name: CreateCommentUnVote :exec
INSERT INTO comment_votes (address, comment_id, vote)
VALUES ($1, $2, 0)
ON CONFLICT (address, comment_id) DO UPDATE SET vote = 0, updated_at = NOW()
WHERE comment_votes.updated_at < TO_TIMESTAMP($3)
`

type CreateCommentUnVoteParams struct {
	Address     string
	CommentID   int64
	ToTimestamp float64
}

func (q *Queries) CreateCommentUnVote(ctx context.Context, arg CreateCommentUnVoteParams) error {
	_, err := q.db.Exec(ctx, createCommentUnVote, arg.Address, arg.CommentID, arg.ToTimestamp)
	return err
}

const createCommentUpVote = `-- name: CreateCommentUpVote :exec
INSERT INTO comment_votes (address, comment_id, vote)
VALUES ($1, $2, 1)
ON CONFLICT (address, comment_id) DO UPDATE SET vote = 1, updated_at = NOW()
WHERE comment_votes.updated_at < TO_TIMESTAMP($3)
`

type CreateCommentUpVoteParams struct {
	Address     string
	CommentID   int64
	ToTimestamp float64
}

func (q *Queries) CreateCommentUpVote(ctx context.Context, arg CreateCommentUpVoteParams) error {
	_, err := q.db.Exec(ctx, createCommentUpVote, arg.Address, arg.CommentID, arg.ToTimestamp)
	return err
}

const createThread = `-- name: CreateThread :one
INSERT INTO threads (address, title, content, image_file_name, image_original_url, image_original_content_type, image_formatted_url, image_formatted_content_type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id
`

type CreateThreadParams struct {
	Address                   string
	Title                     string
	Content                   string
	ImageFileName             string
	ImageOriginalUrl          string
	ImageOriginalContentType  string
	ImageFormattedUrl         string
	ImageFormattedContentType string
}

func (q *Queries) CreateThread(ctx context.Context, arg CreateThreadParams) (int64, error) {
	row := q.db.QueryRow(ctx, createThread,
		arg.Address,
		arg.Title,
		arg.Content,
		arg.ImageFileName,
		arg.ImageOriginalUrl,
		arg.ImageOriginalContentType,
		arg.ImageFormattedUrl,
		arg.ImageFormattedContentType,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createThreadDownVote = `-- name: CreateThreadDownVote :exec

INSERT INTO thread_votes (address, thread_id, vote)
VALUES ($1, $2, -1)
ON CONFLICT (address, thread_id) DO UPDATE SET vote = -1, updated_at = NOW()
WHERE thread_votes.updated_at < TO_TIMESTAMP($3)
`

type CreateThreadDownVoteParams struct {
	Address     string
	ThreadID    int64
	ToTimestamp float64
}

// only update the vote if the incoming vote is newer than the current vote
func (q *Queries) CreateThreadDownVote(ctx context.Context, arg CreateThreadDownVoteParams) error {
	_, err := q.db.Exec(ctx, createThreadDownVote, arg.Address, arg.ThreadID, arg.ToTimestamp)
	return err
}

const createThreadUnVote = `-- name: CreateThreadUnVote :exec
INSERT INTO thread_votes (address, thread_id, vote)
VALUES ($1, $2, 0)
ON CONFLICT (address, thread_id) DO UPDATE SET vote = 0, updated_at = NOW()
WHERE thread_votes.updated_at < TO_TIMESTAMP($3)
`

type CreateThreadUnVoteParams struct {
	Address     string
	ThreadID    int64
	ToTimestamp float64
}

func (q *Queries) CreateThreadUnVote(ctx context.Context, arg CreateThreadUnVoteParams) error {
	_, err := q.db.Exec(ctx, createThreadUnVote, arg.Address, arg.ThreadID, arg.ToTimestamp)
	return err
}

const createThreadUpVote = `-- name: CreateThreadUpVote :exec
INSERT INTO thread_votes (address, thread_id, vote)
VALUES ($1, $2, 1)
ON CONFLICT (address, thread_id) DO UPDATE SET vote = 1, updated_at = NOW()
WHERE thread_votes.updated_at < TO_TIMESTAMP($3)
`

type CreateThreadUpVoteParams struct {
	Address     string
	ThreadID    int64
	ToTimestamp float64
}

func (q *Queries) CreateThreadUpVote(ctx context.Context, arg CreateThreadUpVoteParams) error {
	_, err := q.db.Exec(ctx, createThreadUpVote, arg.Address, arg.ThreadID, arg.ToTimestamp)
	return err
}

const deleteComment = `-- name: DeleteComment :one
UPDATE comments
SET is_deleted = TRUE, deleted_at = NOW()
WHERE id = $1
RETURNING id as comment_id
`

func (q *Queries) DeleteComment(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, deleteComment, id)
	var comment_id int64
	err := row.Scan(&comment_id)
	return comment_id, err
}

const deleteThread = `-- name: DeleteThread :one
UPDATE threads
SET is_deleted = TRUE, deleted_at = NOW()
WHERE id = $1
RETURNING id as thread_id
`

func (q *Queries) DeleteThread(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, deleteThread, id)
	var thread_id int64
	err := row.Scan(&thread_id)
	return thread_id, err
}

const getChallenge = `-- name: GetChallenge :one
SELECT address, message, expires_at
FROM challenges
WHERE address = $1
`

func (q *Queries) GetChallenge(ctx context.Context, address string) (Challenge, error) {
	row := q.db.QueryRow(ctx, getChallenge, address)
	var i Challenge
	err := row.Scan(&i.Address, &i.Message, &i.ExpiresAt)
	return i, err
}

const getComment = `-- name: GetComment :one
SELECT
	c.id, c.thread_id, c.replied_to_comment_id, c.address, c.content, c.image_file_name, c.image_original_url, c.image_original_content_type, c.image_formatted_url, c.image_formatted_content_type, c.votes, c.is_deleted, c.created_at, c.deleted_at,
	r.id as r_id,
	r.address as r_address,
	r.content as r_content,
	r.image_file_name as r_image_file_name,
	r.image_original_url as r_image_original_url,
	r.image_original_content_type as r_image_original_content_type,
	r.image_formatted_url as r_image_formatted_url,
	r.image_formatted_content_type as r_image_formatted_content_type,
	r.is_deleted as r_is_deleted,
	r.created_at as r_created_at,
	r.deleted_at as r_deleted_at,
	u.address as address,
	u.ens_name as ens_name,
	u.ens_avatar_file_name as ens_avatar_file_name,
	u.ens_avatar_original_url as ens_avatar_original_url,
	u.ens_avatar_original_content_type as ens_avatar_original_content_type,
	u.ens_avatar_formatted_url as ens_avatar_formatted_url,
	u.ens_avatar_formatted_content_type as ens_avatar_formatted_content_type,
	u.reputation as reputation,
	u.created_at as user_created_at,
	u.updated_at as user_updated_at
FROM comments c
INNER JOIN users u on c.address = u.address
LEFT JOIN comments r on c.replied_to_comment_id = r.id
WHERE c.id = $1
`

type GetCommentRow struct {
	ID                            int64
	ThreadID                      int64
	RepliedToCommentID            pgtype.Int8
	Address                       string
	Content                       string
	ImageFileName                 string
	ImageOriginalUrl              string
	ImageOriginalContentType      string
	ImageFormattedUrl             string
	ImageFormattedContentType     string
	Votes                         int64
	IsDeleted                     bool
	CreatedAt                     pgtype.Timestamp
	DeletedAt                     pgtype.Timestamp
	RID                           pgtype.Int8
	RAddress                      pgtype.Text
	RContent                      pgtype.Text
	RImageFileName                pgtype.Text
	RImageOriginalUrl             pgtype.Text
	RImageOriginalContentType     pgtype.Text
	RImageFormattedUrl            pgtype.Text
	RImageFormattedContentType    pgtype.Text
	RIsDeleted                    pgtype.Bool
	RCreatedAt                    pgtype.Timestamp
	RDeletedAt                    pgtype.Timestamp
	Address_2                     string
	EnsName                       pgtype.Text
	EnsAvatarFileName             pgtype.Text
	EnsAvatarOriginalUrl          pgtype.Text
	EnsAvatarOriginalContentType  pgtype.Text
	EnsAvatarFormattedUrl         pgtype.Text
	EnsAvatarFormattedContentType pgtype.Text
	Reputation                    int64
	UserCreatedAt                 pgtype.Timestamp
	UserUpdatedAt                 pgtype.Timestamp
}

func (q *Queries) GetComment(ctx context.Context, id int64) (GetCommentRow, error) {
	row := q.db.QueryRow(ctx, getComment, id)
	var i GetCommentRow
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.RepliedToCommentID,
		&i.Address,
		&i.Content,
		&i.ImageFileName,
		&i.ImageOriginalUrl,
		&i.ImageOriginalContentType,
		&i.ImageFormattedUrl,
		&i.ImageFormattedContentType,
		&i.Votes,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.RID,
		&i.RAddress,
		&i.RContent,
		&i.RImageFileName,
		&i.RImageOriginalUrl,
		&i.RImageOriginalContentType,
		&i.RImageFormattedUrl,
		&i.RImageFormattedContentType,
		&i.RIsDeleted,
		&i.RCreatedAt,
		&i.RDeletedAt,
		&i.Address_2,
		&i.EnsName,
		&i.EnsAvatarFileName,
		&i.EnsAvatarOriginalUrl,
		&i.EnsAvatarOriginalContentType,
		&i.EnsAvatarFormattedUrl,
		&i.EnsAvatarFormattedContentType,
		&i.Reputation,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
	)
	return i, err
}

const getComments = `-- name: GetComments :many
SELECT
	c.id, c.thread_id, c.replied_to_comment_id, c.address, c.content, c.image_file_name, c.image_original_url, c.image_original_content_type, c.image_formatted_url, c.image_formatted_content_type, c.votes, c.is_deleted, c.created_at, c.deleted_at,
	r.id as r_id,
	r.address as r_address,
	r.content as r_content,
	r.image_file_name as r_image_file_name,
	r.image_original_url as r_image_original_url,
	r.image_original_content_type as r_image_original_content_type,
	r.image_formatted_url as r_image_formatted_url,
	r.image_formatted_content_type as r_image_formatted_content_type,
	r.is_deleted as r_is_deleted,
	r.created_at as r_created_at,
	r.deleted_at as r_deleted_at,
	u.address as address,
	u.ens_name as ens_name,
	u.ens_avatar_file_name as ens_avatar_file_name,
	u.ens_avatar_original_url as ens_avatar_original_url,
	u.ens_avatar_original_content_type as ens_avatar_original_content_type,
	u.ens_avatar_formatted_url as ens_avatar_formatted_url,
	u.ens_avatar_formatted_content_type as ens_avatar_formatted_content_type,
	u.reputation as reputation,
	u.created_at as user_created_at,
	u.updated_at as user_updated_at,
	count(*) OVER() AS full_count
FROM comments c
INNER JOIN users u on c.address = u.address
LEFT JOIN comments r on c.replied_to_comment_id = r.id
WHERE c.thread_id = $1
AND c.is_deleted = FALSE
ORDER BY c.created_at DESC
OFFSET $2::bigint
LIMIT $3::bigint
`

type GetCommentsParams struct {
	ThreadID int64
	Column2  int64
	Column3  int64
}

type GetCommentsRow struct {
	ID                            int64
	ThreadID                      int64
	RepliedToCommentID            pgtype.Int8
	Address                       string
	Content                       string
	ImageFileName                 string
	ImageOriginalUrl              string
	ImageOriginalContentType      string
	ImageFormattedUrl             string
	ImageFormattedContentType     string
	Votes                         int64
	IsDeleted                     bool
	CreatedAt                     pgtype.Timestamp
	DeletedAt                     pgtype.Timestamp
	RID                           pgtype.Int8
	RAddress                      pgtype.Text
	RContent                      pgtype.Text
	RImageFileName                pgtype.Text
	RImageOriginalUrl             pgtype.Text
	RImageOriginalContentType     pgtype.Text
	RImageFormattedUrl            pgtype.Text
	RImageFormattedContentType    pgtype.Text
	RIsDeleted                    pgtype.Bool
	RCreatedAt                    pgtype.Timestamp
	RDeletedAt                    pgtype.Timestamp
	Address_2                     string
	EnsName                       pgtype.Text
	EnsAvatarFileName             pgtype.Text
	EnsAvatarOriginalUrl          pgtype.Text
	EnsAvatarOriginalContentType  pgtype.Text
	EnsAvatarFormattedUrl         pgtype.Text
	EnsAvatarFormattedContentType pgtype.Text
	Reputation                    int64
	UserCreatedAt                 pgtype.Timestamp
	UserUpdatedAt                 pgtype.Timestamp
	FullCount                     int64
}

func (q *Queries) GetComments(ctx context.Context, arg GetCommentsParams) ([]GetCommentsRow, error) {
	rows, err := q.db.Query(ctx, getComments, arg.ThreadID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsRow
	for rows.Next() {
		var i GetCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.RepliedToCommentID,
			&i.Address,
			&i.Content,
			&i.ImageFileName,
			&i.ImageOriginalUrl,
			&i.ImageOriginalContentType,
			&i.ImageFormattedUrl,
			&i.ImageFormattedContentType,
			&i.Votes,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.RID,
			&i.RAddress,
			&i.RContent,
			&i.RImageFileName,
			&i.RImageOriginalUrl,
			&i.RImageOriginalContentType,
			&i.RImageFormattedUrl,
			&i.RImageFormattedContentType,
			&i.RIsDeleted,
			&i.RCreatedAt,
			&i.RDeletedAt,
			&i.Address_2,
			&i.EnsName,
			&i.EnsAvatarFileName,
			&i.EnsAvatarOriginalUrl,
			&i.EnsAvatarOriginalContentType,
			&i.EnsAvatarFormattedUrl,
			&i.EnsAvatarFormattedContentType,
			&i.Reputation,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
			&i.FullCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThread = `-- name: GetThread :one
SELECT 
	t.id, t.address, t.title, t.content, t.image_file_name, t.image_original_url, t.image_original_content_type, t.image_formatted_url, t.image_formatted_content_type, t.votes, t.is_deleted, t.created_at, t.deleted_at,
	u.address as address,
	u.ens_name as ens_name,
	u.ens_avatar_file_name as ens_avatar_file_name,
	u.ens_avatar_original_url as ens_avatar_original_url,
	u.ens_avatar_original_content_type as ens_avatar_original_content_type,
	u.ens_avatar_formatted_url as ens_avatar_formatted_url,
	u.ens_avatar_formatted_content_type as ens_avatar_formatted_content_type,
	u.reputation as reputation,
	u.created_at as user_created_at,
	u.updated_at as user_updated_at
FROM threads t
INNER JOIN users u on t.address = u.address
WHERE t.id = $1
AND t.is_deleted = FALSE
`

type GetThreadRow struct {
	ID                            int64
	Address                       string
	Title                         string
	Content                       string
	ImageFileName                 string
	ImageOriginalUrl              string
	ImageOriginalContentType      string
	ImageFormattedUrl             string
	ImageFormattedContentType     string
	Votes                         int64
	IsDeleted                     bool
	CreatedAt                     pgtype.Timestamp
	DeletedAt                     pgtype.Timestamp
	Address_2                     string
	EnsName                       pgtype.Text
	EnsAvatarFileName             pgtype.Text
	EnsAvatarOriginalUrl          pgtype.Text
	EnsAvatarOriginalContentType  pgtype.Text
	EnsAvatarFormattedUrl         pgtype.Text
	EnsAvatarFormattedContentType pgtype.Text
	Reputation                    int64
	UserCreatedAt                 pgtype.Timestamp
	UserUpdatedAt                 pgtype.Timestamp
}

func (q *Queries) GetThread(ctx context.Context, id int64) (GetThreadRow, error) {
	row := q.db.QueryRow(ctx, getThread, id)
	var i GetThreadRow
	err := row.Scan(
		&i.ID,
		&i.Address,
		&i.Title,
		&i.Content,
		&i.ImageFileName,
		&i.ImageOriginalUrl,
		&i.ImageOriginalContentType,
		&i.ImageFormattedUrl,
		&i.ImageFormattedContentType,
		&i.Votes,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Address_2,
		&i.EnsName,
		&i.EnsAvatarFileName,
		&i.EnsAvatarOriginalUrl,
		&i.EnsAvatarOriginalContentType,
		&i.EnsAvatarFormattedUrl,
		&i.EnsAvatarFormattedContentType,
		&i.Reputation,
		&i.UserCreatedAt,
		&i.UserUpdatedAt,
	)
	return i, err
}

const getThreads = `-- name: GetThreads :many
SELECT
	t.id, t.address, t.title, t.content, t.image_file_name, t.image_original_url, t.image_original_content_type, t.image_formatted_url, t.image_formatted_content_type, t.votes, t.is_deleted, t.created_at, t.deleted_at,
	u.address as address,
	u.ens_name as ens_name,
	u.ens_avatar_file_name as ens_avatar_file_name,
	u.ens_avatar_original_url as ens_avatar_original_url,
	u.ens_avatar_original_content_type as ens_avatar_original_content_type,
	u.ens_avatar_formatted_url as ens_avatar_formatted_url,
	u.ens_avatar_formatted_content_type as ens_avatar_formatted_content_type,
	u.reputation as reputation,
	u.created_at as user_created_at,
	u.updated_at as user_updated_at
FROM threads t
INNER JOIN users u on t.address = u.address
WHERE t.is_deleted = FALSE
ORDER BY RANDOM()
LIMIT $1::bigint
`

type GetThreadsRow struct {
	ID                            int64
	Address                       string
	Title                         string
	Content                       string
	ImageFileName                 string
	ImageOriginalUrl              string
	ImageOriginalContentType      string
	ImageFormattedUrl             string
	ImageFormattedContentType     string
	Votes                         int64
	IsDeleted                     bool
	CreatedAt                     pgtype.Timestamp
	DeletedAt                     pgtype.Timestamp
	Address_2                     string
	EnsName                       pgtype.Text
	EnsAvatarFileName             pgtype.Text
	EnsAvatarOriginalUrl          pgtype.Text
	EnsAvatarOriginalContentType  pgtype.Text
	EnsAvatarFormattedUrl         pgtype.Text
	EnsAvatarFormattedContentType pgtype.Text
	Reputation                    int64
	UserCreatedAt                 pgtype.Timestamp
	UserUpdatedAt                 pgtype.Timestamp
}

// Order by random is not performant as we need to do a full table scan.
// Move to TABLESAMPLE SYSTEM_ROWS(N) when performance becomes an issue.
// Table sample is not random enough until the table gets big.
// https://www.postgresql.org/docs/current/tsm-system-rows.html
func (q *Queries) GetThreads(ctx context.Context, dollar_1 int64) ([]GetThreadsRow, error) {
	rows, err := q.db.Query(ctx, getThreads, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsRow
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Address,
			&i.Title,
			&i.Content,
			&i.ImageFileName,
			&i.ImageOriginalUrl,
			&i.ImageOriginalContentType,
			&i.ImageFormattedUrl,
			&i.ImageFormattedContentType,
			&i.Votes,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Address_2,
			&i.EnsName,
			&i.EnsAvatarFileName,
			&i.EnsAvatarOriginalUrl,
			&i.EnsAvatarOriginalContentType,
			&i.EnsAvatarFormattedUrl,
			&i.EnsAvatarFormattedContentType,
			&i.Reputation,
			&i.UserCreatedAt,
			&i.UserUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT address, ens_name, created_at, updated_at, reputation, ens_avatar_file_name, ens_avatar_original_url, ens_avatar_original_content_type, ens_avatar_formatted_url, ens_avatar_formatted_content_type
FROM users
WHERE address = $1
`

func (q *Queries) GetUser(ctx context.Context, address string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, address)
	var i User
	err := row.Scan(
		&i.Address,
		&i.EnsName,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Reputation,
		&i.EnsAvatarFileName,
		&i.EnsAvatarOriginalUrl,
		&i.EnsAvatarOriginalContentType,
		&i.EnsAvatarFormattedUrl,
		&i.EnsAvatarFormattedContentType,
	)
	return i, err
}

const updateChallenge = `-- name: UpdateChallenge :exec
INSERT INTO challenges (address, message, expires_at)
VALUES ($1, $2, $3)
ON CONFLICT (address) DO UPDATE
SET message = $2, expires_at = $3
`

type UpdateChallengeParams struct {
	Address   string
	Message   string
	ExpiresAt int64
}

func (q *Queries) UpdateChallenge(ctx context.Context, arg UpdateChallengeParams) error {
	_, err := q.db.Exec(ctx, updateChallenge, arg.Address, arg.Message, arg.ExpiresAt)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
	ens_name = $2,
	ens_avatar_file_name = $3,
	ens_avatar_original_url = $4,
	ens_avatar_original_content_type = $5,
	ens_avatar_formatted_url = $6,
	ens_avatar_formatted_content_type = $7,
	updated_at = NOW()
WHERE address = $1
`

type UpdateUserParams struct {
	Address                       string
	EnsName                       pgtype.Text
	EnsAvatarFileName             pgtype.Text
	EnsAvatarOriginalUrl          pgtype.Text
	EnsAvatarOriginalContentType  pgtype.Text
	EnsAvatarFormattedUrl         pgtype.Text
	EnsAvatarFormattedContentType pgtype.Text
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Address,
		arg.EnsName,
		arg.EnsAvatarFileName,
		arg.EnsAvatarOriginalUrl,
		arg.EnsAvatarOriginalContentType,
		arg.EnsAvatarFormattedUrl,
		arg.EnsAvatarFormattedContentType,
	)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
INSERT INTO users (address)
VALUES ($1)
ON CONFLICT (address) DO NOTHING
`

// upsert user every time they signin so we don't have to check if they exist
func (q *Queries) UpsertUser(ctx context.Context, address string) error {
	_, err := q.db.Exec(ctx, upsertUser, address)
	return err
}
